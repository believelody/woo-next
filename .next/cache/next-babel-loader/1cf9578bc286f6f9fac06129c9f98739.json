{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport const createCart = (product, quantity, variationValue) => {\n  let rawPrice = parseFloat(product.price.replace(\",\", \".\").substring(1));\n  let indexVariation = product.variations.nodes.findIndex(variation => variation.attributes.nodes[0].value === variationValue);\n\n  if (indexVariation > -1) {\n    return [{\n      totalPrice: (quantity * rawPrice).toFixed(2),\n      quantity,\n      variation: variationValue,\n      productVariation: product\n    }];\n  }\n\n  return null;\n};\nexport const updateCart = (cart, product, quantity, variationValue) => {\n  console.log(product);\n  const isProductMatch = cart.find(item => item.productVariation.id === product.id);\n  const isVariationMatch = isProductMatch && isProductMatch.variation === variationValue;\n  let rawPrice = parseFloat(product.price.replace(\",\", \".\").substring(1));\n  let indexVariation = product.variations.nodes.findIndex(variation => variation.attributes.nodes[0].value === variationValue);\n\n  if (indexVariation > -1) {\n    if (isVariationMatch) {\n      return [...cart, _objectSpread(_objectSpread({}, isProductMatch), {}, {\n        quantity: isProductMatch.quantity + quantity\n      })];\n    } else {\n      return [...cart, {\n        quantity,\n        totalPrice: (quantity * rawPrice).toFixed(2),\n        productVariation: product\n      }];\n    }\n  }\n\n  return null;\n};","map":{"version":3,"sources":["/home/yamakasi/nextjs/woo-next/utils/cart.util.js"],"names":["createCart","product","quantity","variationValue","rawPrice","parseFloat","price","replace","substring","indexVariation","variations","nodes","findIndex","variation","attributes","value","totalPrice","toFixed","productVariation","updateCart","cart","console","log","isProductMatch","find","item","id","isVariationMatch"],"mappings":";;;;;;AAAA,OAAO,MAAMA,UAAU,GAAG,CAACC,OAAD,EAAUC,QAAV,EAAoBC,cAApB,KAAuC;AAC7D,MAAIC,QAAQ,GAAGC,UAAU,CAACJ,OAAO,CAACK,KAAR,CAAcC,OAAd,CAAsB,GAAtB,EAA2B,GAA3B,EAAgCC,SAAhC,CAA0C,CAA1C,CAAD,CAAzB;AACA,MAAIC,cAAc,GAAGR,OAAO,CAACS,UAAR,CAAmBC,KAAnB,CAAyBC,SAAzB,CAAmCC,SAAS,IAAIA,SAAS,CAACC,UAAV,CAAqBH,KAArB,CAA2B,CAA3B,EAA8BI,KAA9B,KAAwCZ,cAAxF,CAArB;;AACA,MAAIM,cAAc,GAAG,CAAC,CAAtB,EAAyB;AACrB,WAAO,CACH;AACIO,MAAAA,UAAU,EAAE,CAACd,QAAQ,GAAGE,QAAZ,EAAsBa,OAAtB,CAA8B,CAA9B,CADhB;AAEIf,MAAAA,QAFJ;AAGIW,MAAAA,SAAS,EAAEV,cAHf;AAIIe,MAAAA,gBAAgB,EAAEjB;AAJtB,KADG,CAAP;AAQH;;AACD,SAAO,IAAP;AACH,CAdM;AAgBP,OAAO,MAAMkB,UAAU,GAAG,CAACC,IAAD,EAAOnB,OAAP,EAAgBC,QAAhB,EAA0BC,cAA1B,KAA6C;AACnEkB,EAAAA,OAAO,CAACC,GAAR,CAAYrB,OAAZ;AACA,QAAMsB,cAAc,GAAGH,IAAI,CAACI,IAAL,CAAUC,IAAI,IAAIA,IAAI,CAACP,gBAAL,CAAsBQ,EAAtB,KAA6BzB,OAAO,CAACyB,EAAvD,CAAvB;AACA,QAAMC,gBAAgB,GAAGJ,cAAc,IAAIA,cAAc,CAACV,SAAf,KAA6BV,cAAxE;AACA,MAAIC,QAAQ,GAAGC,UAAU,CAACJ,OAAO,CAACK,KAAR,CAAcC,OAAd,CAAsB,GAAtB,EAA2B,GAA3B,EAAgCC,SAAhC,CAA0C,CAA1C,CAAD,CAAzB;AACA,MAAIC,cAAc,GAAGR,OAAO,CAACS,UAAR,CAAmBC,KAAnB,CAAyBC,SAAzB,CAAmCC,SAAS,IAAIA,SAAS,CAACC,UAAV,CAAqBH,KAArB,CAA2B,CAA3B,EAA8BI,KAA9B,KAAwCZ,cAAxF,CAArB;;AACA,MAAIM,cAAc,GAAG,CAAC,CAAtB,EAAyB;AACrB,QAAIkB,gBAAJ,EAAsB;AAClB,aAAO,CAAC,GAAGP,IAAJ,kCAAcG,cAAd;AAA8BrB,QAAAA,QAAQ,EAAEqB,cAAc,CAACrB,QAAf,GAA0BA;AAAlE,SAAP;AACH,KAFD,MAGK;AACD,aAAO,CACH,GAAGkB,IADA,EAEH;AACIlB,QAAAA,QADJ;AAEIc,QAAAA,UAAU,EAAE,CAACd,QAAQ,GAAGE,QAAZ,EAAsBa,OAAtB,CAA8B,CAA9B,CAFhB;AAGIC,QAAAA,gBAAgB,EAAEjB;AAHtB,OAFG,CAAP;AAQH;AACJ;;AACD,SAAO,IAAP;AACH,CAtBM","sourcesContent":["export const createCart = (product, quantity, variationValue) => {\n    let rawPrice = parseFloat(product.price.replace(\",\", \".\").substring(1))\n    let indexVariation = product.variations.nodes.findIndex(variation => variation.attributes.nodes[0].value === variationValue)\n    if (indexVariation > -1) {\n        return [\n            {\n                totalPrice: (quantity * rawPrice).toFixed(2),\n                quantity,\n                variation: variationValue,\n                productVariation: product\n            }\n        ]\n    }\n    return null\n}\n\nexport const updateCart = (cart, product, quantity, variationValue) => {\n    console.log(product)\n    const isProductMatch = cart.find(item => item.productVariation.id === product.id)\n    const isVariationMatch = isProductMatch && isProductMatch.variation === variationValue\n    let rawPrice = parseFloat(product.price.replace(\",\", \".\").substring(1))\n    let indexVariation = product.variations.nodes.findIndex(variation => variation.attributes.nodes[0].value === variationValue)\n    if (indexVariation > -1) {\n        if (isVariationMatch) {\n            return [...cart, {...isProductMatch, quantity: isProductMatch.quantity + quantity}]\n        }\n        else {\n            return [\n                ...cart,\n                {\n                    quantity,\n                    totalPrice: (quantity * rawPrice).toFixed(2),\n                    productVariation: product\n                }\n            ]\n        }\n    }\n    return null\n}"]},"metadata":{},"sourceType":"module"}